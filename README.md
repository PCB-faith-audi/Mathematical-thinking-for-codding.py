**Mathematical Thinking for Coding**

This repository contains compact code examples and exercises to build strong mathematical thinking for programming. The goal is to teach patterns, problem decomposition, and rigorous reasoning so you can design correct and efficient algorithms.

**Who This Is For**
- **Beginners:** programmers who want to apply math to code (logic, discrete math, proofs).
- **Intermediate devs:** who want clearer mental models for algorithms and complexity.

**Learning Goals**
- **Model problems mathematically:** translate real problems into math statements.
- **Reason with invariants and proofs:** understand correctness and edge cases.
- **Analyze complexity:** derive time/space bounds and optimize.
- **Design algorithms:** from brute force to greedy, divide-and-conquer, dynamic programming.

**How To Use This Repo**
1. Explore small files (graphs, sets, numbers) as worked examples.
2. Read the problem description, try to solve on paper first, then implement.
3. Run and step through the code with small inputs to observe behavior.
4. Attempt the exercises in the `exercises/` section below, then check reference implementations.

**Suggested Learning Path (8 weeks)**
- Week 1: Logic, sets, functions, and basic proofs (induction/simple invariants).
- Week 2: Number theory basics and integer reasoning (divisibility, gcd, modular arithmetic).
- Week 3: Discrete structures: graphs and trees — traversal and representation.
- Week 4: Sorting, searching, and greedy strategies.
- Week 5: Recursion and divide-and-conquer (quicksort, mergesort, recursion invariants).
- Week 6: Dynamic programming patterns and memoization.
- Week 7: Complexity analysis and amortized reasoning.
- Week 8: Projects: small algorithmic project (e.g., pathfinding, convex hull, knapsack variants).

**Exercises (practice problems)**
- Implement and prove correctness for DFS and BFS; analyze time/space.
- Implement randomized quicksort; reason about expected complexity.
- Solve small dynamic programming problems (subset sum, longest increasing subsequence).
- Implement convex hull (Graham scan) and explain why it works.
- Implement knapsack branch-and-bound and compare to DP solution.

**Advice & Techniques**
- Work on paper first: write invariants and small proofs before coding.
- Use examples and counterexamples to validate edge cases.
- Start from brute force; then identify patterns to optimize.
- Trace small inputs by hand and with the debugger.
- Keep implementations small and well-tested.

**Resources**
- Book: "How to Prove It" by Daniel Velleman — foundations for rigorous reasoning.
- Book: "Introduction to Algorithms" (CLRS) — for algorithms and proofs.
- Online: MIT OCW, Coursera algorithms courses, Project Euler for problem practice.

**Contributing**
- Add small, self-contained examples and short write-ups explaining the math behind them.
- Keep files named to avoid shadowing Python stdlib (avoid names like `math.py`).

**License**
- CC0 / Public Domain — use and adapt freely for learning.

Enjoy learning — ask questions, open issues, and propose additional exercises.
